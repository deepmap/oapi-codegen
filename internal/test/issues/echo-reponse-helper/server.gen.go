// Package echo_reponse_helper provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version (devel) DO NOT EDIT.
package echo_reponse_helper

import (
	"errors"
	"fmt"

	"github.com/labstack/echo/v4"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Error defines model for Error.
type Error struct {
	// Error code
	Code int32 `json:"code"`

	// Error message
	Message string `json:"message"`
}

// Thing defines model for Thing.
type Thing struct {
	Name string `json:"name"`
}

// ThingWithID defines model for ThingWithID.
type ThingWithID struct {
	// Embedded struct due to allOf(#/components/schemas/Thing)
	Thing `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Id int64 `json:"id"`
}

// AddThingJSONBody defines parameters for AddThing.
type AddThingJSONBody Thing

// AddThingJSONRequestBody defines body for AddThing for application/json ContentType.
type AddThingJSONRequestBody AddThingJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /things)
	ListThings(ctx ListThingsContext) error

	// (POST /things)
	AddThing(ctx AddThingContext) error
}

type ListThingsContext struct {
	echo.Context
}

func (c *ListThingsContext) JSON200(resp []ThingWithID) error {
	err := c.Validate(resp)
	if err != nil {
		return err
	}
	return c.JSON(200, resp)
}

type AddThingContext struct {
	echo.Context
}

func (c *AddThingContext) JSON201(resp []ThingWithID) error {
	err := c.Validate(resp)
	if err != nil {
		return err
	}
	return c.JSON(201, resp)
}

func (c *AddThingContext) JSON400(resp Error) error {
	err := c.Validate(resp)
	if err != nil {
		return err
	}
	return c.JSON(400, resp)
}

func (c *AddThingContext) BindJSON() (*AddThingJSONBody, error) {
	var err error

	// optional
	if c.Request().ContentLength == 0 {
		return nil, errors.New("the request body should not be empty")
	}

	ctype := c.Request().Header.Get(echo.HeaderContentType)
	if ctype != "application/json" {
		err = errors.New(fmt.Sprintf("incorrect content type: %s", ctype))
		return nil, err
	}

	var result AddThingJSONBody
	if err = c.Bind(&result); err != nil {
		return nil, err
	}

	if err = c.Validate(result); err != nil {
		return nil, err
	}

	return &result, nil
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListThings converts echo context to params.
func (w *ServerInterfaceWrapper) ListThings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListThings(ListThingsContext{ctx})
	return err
}

// AddThing converts echo context to params.
func (w *ServerInterfaceWrapper) AddThing(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{"things:w"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddThing(AddThingContext{ctx})
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/things", wrapper.ListThings)
	router.POST(baseURL+"/things", wrapper.AddThing)

}
