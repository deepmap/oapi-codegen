// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/deepmap/oapi-codegen/pkg/xmlutil"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi"
	"github.com/pkg/errors"
	"net/http"
	"strings"
)

// Error defines model for Error.
type Error struct {
	Code    int32  `json:"code" xml:"code"`
	Message string `json:"message" xml:"message"`
}

// NewPet defines model for NewPet.
type NewPet struct {
	Name string  `json:"name" xml:"name"`
	Tag  *string `json:"tag,omitempty" xml:"tag,omitempty"`
}

// Pet defines model for Pet.
type Pet struct {
	// Embedded struct due to allOf(#/components/schemas/NewPet)
	NewPet
	// Embedded fields due to inline allOf schema
	Id int64 `json:"id" xml:"id"`
}

// PetDescribed defines model for PetDescribed.
type PetDescribed struct {
	// Embedded struct due to allOf(#/components/schemas/Pet)
	Pet
	// Embedded fields due to inline allOf schema
	Dictionary *PetDescribed_Dictionary `json:"dictionary,omitempty" xml:"dictionary,omitempty"`
}

// PetDescribed_Dictionary defines model for PetDescribed.Dictionary.
type PetDescribed_Dictionary struct {
	Description          *string `json:"description,omitempty" xml:"description,omitempty"`
	AdditionalProperties map[string]struct {
		Code *int    `json:"code,omitempty" xml:"code,omitempty"`
		Text *string `json:"text,omitempty" xml:"text,omitempty"`
	} `json:"-" xml:"-"`
}

// FindPetsParams defines parameters for FindPets.
type FindPetsParams struct {

	// tags to filter by
	Tags *[]string `json:"tags,omitempty" xml:"tags-list>tags,omitempty"`

	// maximum number of results to return
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
}

// addPetJSONBody defines parameters for AddPet.
type addPetJSONBody NewPet

// updatePetByIdJSONBody defines parameters for UpdatePetById.
type updatePetByIdJSONBody PetDescribed

// AddPetRequestBody defines body for AddPet for application/json ContentType.
type AddPetJSONRequestBody addPetJSONBody

// UpdatePetByIdRequestBody defines body for UpdatePetById for application/json ContentType.
type UpdatePetByIdJSONRequestBody updatePetByIdJSONBody

// Getter for additional properties for PetDescribed_Dictionary. Returns the specified
// element and whether it was found
func (a PetDescribed_Dictionary) Get(fieldName string) (value struct {
	Code *int    `json:"code,omitempty" xml:"code,omitempty"`
	Text *string `json:"text,omitempty" xml:"text,omitempty"`
}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PetDescribed_Dictionary
func (a *PetDescribed_Dictionary) Set(fieldName string, value struct {
	Code *int    `json:"code,omitempty" xml:"code,omitempty"`
	Text *string `json:"text,omitempty" xml:"text,omitempty"`
}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]struct {
			Code *int    `json:"code,omitempty" xml:"code,omitempty"`
			Text *string `json:"text,omitempty" xml:"text,omitempty"`
		})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PetDescribed_Dictionary to handle AdditionalProperties
func (a *PetDescribed_Dictionary) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return errors.Wrap(err, "error reading 'description'")
		}
		delete(object, "description")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]struct {
			Code *int    `json:"code,omitempty" xml:"code,omitempty"`
			Text *string `json:"text,omitempty" xml:"text,omitempty"`
		})
		for fieldName, fieldBuf := range object {
			var fieldVal struct {
				Code *int    `json:"code,omitempty" xml:"code,omitempty"`
				Text *string `json:"text,omitempty" xml:"text,omitempty"`
			}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PetDescribed_Dictionary to handle AdditionalProperties
func (a PetDescribed_Dictionary) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'description'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Override default XML handling for PetDescribed_Dictionary to handle AdditionalProperties
func (a *PetDescribed_Dictionary) UnmarshalXML(b []byte) error {
	object := make(map[string]xmlutil.RawMessage)
	err := xml.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = xml.Unmarshal(raw, &a.Description)
		if err != nil {
			return errors.Wrap(err, "error reading 'description'")
		}
		delete(object, "description")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]struct {
			Code *int    `json:"code,omitempty" xml:"code,omitempty"`
			Text *string `json:"text,omitempty" xml:"text,omitempty"`
		})
		for fieldName, fieldBuf := range object {
			var fieldVal struct {
				Code *int    `json:"code,omitempty" xml:"code,omitempty"`
				Text *string `json:"text,omitempty" xml:"text,omitempty"`
			}
			err := xml.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default XML handling for PetDescribed_Dictionary to handle AdditionalProperties
func (a PetDescribed_Dictionary) MarshalXML() ([]byte, error) {
	var err error
	object := make(map[string]xmlutil.RawMessage)

	if a.Description != nil {
		object["description"], err = xml.Marshal(a.Description)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'description'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = xml.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return xml.Marshal(object)
}

type ServerInterface interface {
	//  (GET /pets)
	FindPets(w http.ResponseWriter, r *http.Request)
	//  (POST /pets)
	AddPet(w http.ResponseWriter, r *http.Request)
	//  (DELETE /pets/{id})
	DeletePet(w http.ResponseWriter, r *http.Request)
	//  (GET /pets/{id})
	FindPetById(w http.ResponseWriter, r *http.Request)
	//  (PUT /pets/{id})
	UpdatePetById(w http.ResponseWriter, r *http.Request)
}

// ParamsForFindPets operation parameters from context
func ParamsForFindPets(ctx context.Context) *FindPetsParams {
	return ctx.Value("FindPetsParams").(*FindPetsParams)
}

// FindPets operation middleware
func FindPetsCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var err error

		// Parameter object where we will unmarshal all parameters from the context
		var params FindPetsParams

		// ------------- Optional query parameter "tags" -------------
		if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

		}

		err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
			return
		}

		// ------------- Optional query parameter "limit" -------------
		if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

		}

		err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
			return
		}

		ctx = context.WithValue(ctx, "FindPetsParams", &params)

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// AddPet operation middleware
func AddPetCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// DeletePet operation middleware
func DeletePetCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var err error

		// ------------- Path parameter "id" -------------
		var id int64

		err = runtime.BindStyledParameter("simple", false, "id", chi.URLParam(r, "id"), &id)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
			return
		}

		ctx = context.WithValue(r.Context(), "id", id)

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// FindPetById operation middleware
func FindPetByIdCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var err error

		// ------------- Path parameter "id" -------------
		var id int64

		err = runtime.BindStyledParameter("simple", false, "id", chi.URLParam(r, "id"), &id)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
			return
		}

		ctx = context.WithValue(r.Context(), "id", id)

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// UpdatePetById operation middleware
func UpdatePetByIdCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var err error

		// ------------- Path parameter "id" -------------
		var id int64

		err = runtime.BindStyledParameter("simple", false, "id", chi.URLParam(r, "id"), &id)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
			return
		}

		ctx = context.WithValue(r.Context(), "id", id)

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	r := chi.NewRouter()

	r.Group(func(r chi.Router) {
		r.Use(FindPetsCtx)
		r.Get("/pets", si.FindPets)
	})
	r.Group(func(r chi.Router) {
		r.Use(AddPetCtx)
		r.Post("/pets", si.AddPet)
	})
	r.Group(func(r chi.Router) {
		r.Use(DeletePetCtx)
		r.Delete("/pets/{id}", si.DeletePet)
	})
	r.Group(func(r chi.Router) {
		r.Use(FindPetByIdCtx)
		r.Get("/pets/{id}", si.FindPetById)
	})
	r.Group(func(r chi.Router) {
		r.Use(UpdatePetByIdCtx)
		r.Put("/pets/{id}", si.UpdatePetById)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+RYS48buRH+KwUmx05rYi9y0ClejwMMkLUncTaXtQ+lZkkqgy+TRY0Hhv57UGRLGnnk",
	"R5DNwsBe9Ojm46vv+6pY3R/NFH2KgYIUs/xoyrQlj+3ni5xj1h8px0RZmNrlKVrS73XMHsUsDQd5+sQM",
	"Ru4T9b+0oWz2g/FUCm7a6PlmkcxhY/b7wWR6XzmTNctf+pqn8W/3g3lJd7ckj7cP6C8tOBjBzdc3arN1",
	"+XltdO7V2ix/+Wj+mGltluYPixMfi5mMxYxlP3wKhu2nTPzlhwtMfAKCrXm7n0FcU5kyr8h+O5rLUCxP",
	"wjFgvm8rWcvtr7s9G3VZysfKCX2Qy2zOV+LqHU2K41MYLZ6ke3/T/P3+7V4vc1jHDikITm1v8sjOLA0m",
	"FkL/13KHmw3lkaMZZhuY1/0aPLu9gX8RejOYmnXSViQtF4sHc/bDOTjzDAr65KhNli0K1EIFEBJJkZgJ",
	"sAAGoA99mESw5GMoklEI1oRSMxXgALIleJUo6EpPxysoiSZe84Rtq8E4nigUOvnXPEs4bQmejFdnkMty",
	"sbi7uxux3R5j3izmuWXx95vnL16+fvGnJ+PVuBXvuk7Zl1fr15R3PNGluBdtyEJdyeIecnY7h2kGs6Nc",
	"Oil/Hq/GK105JgqY2CzN03ZpMAll2zReKEH6Y9OT6JzWf5LUHAqgc41JWOfoG0Plvgj5TrX+r4UybJXk",
	"aaJSQOKb8BI9FLIwxWDZU5DqgYqM8BPSRAELCPkUMxTcsAgXKJiYwgCBJsjbGKZaoJB/MIAF0JOM8IwC",
	"YQAU2GTcsUXAuqk0AE7AOFXHbeoIz2vGFUvNEC1HcDGTHyDmgJmANiRAjmZ0gaYBpppLLcAWHE1SywjX",
	"lQt4Bqk5cRkgVbfjgFn3ohw16AGEw8S2BoEdZq4F3tUicYSbAFucYKsgsBSC5FAIQZO8eqXjpueqxoKW",
	"E5eJwwYwiEZzit3xpjo8Rp62mEkyHkjU8eCjoyJMwD5RtqxM/Zt36HtA6Ph9RQ+WUZnJWOC9xrYjxwIh",
	"BpCYJWalhNcU7HH3EW4zUqEgCpMC+xOAmgPCLroqCQV2FCigAu7k6ofHmnWNm3BaeU15Zn2NEzsuZ5u0",
	"HfRjOOk7QYkWHamwdlAeJ8ooGph+j/C6lkTBsrLsUM1jo4t5UAcWmkTd3KJsVtGoB9jRlqfqELRiZls9",
	"OF5RjiP8FPOKgSoXH+1DGfR2M7bDiQPj+Ca8Ca/JNiVqgTWp+VxcxdwmUDw5JlfJ1Y+gueGxLTiTz8UN",
	"QPUsW7rk4Kr6UN05wu0WCznXEyNRnqc3mpu8JLDGOvGqdsLxsI+Oezh/R26WjneUMw7nW2ueANvhmIiB",
	"V9sRfhZI5BwFofK+EqRYKmkmHZJoBKUCD1mgSXfg8rDSIazG5NCAHG0RaphAMhfRWGDHgjTC32qZCEha",
	"NbCVj1mglaJM5Chzg9P9e5jg1S0Vm3mm6gsG8LjRkMnNao3wj9qn+uhUt64e1e6dE5ThWHwA66RJ0kfO",
	"9uxhz+aYi8wxG9UsKjBwGE5Q5sQNXPgAuCiGiaVaVqilIFQ5+GwWsu90Rlrbb4Tbh8I05maMKZNw9Q8q",
	"VzdNHR74W0vv+EaPOG0C2nF3Y83SrDlYPV/asZGVAMqldTbnh4XgRus+rNkJZVjdG20FzNK8r5TvT+e8",
	"jjMPu6g1ukLD3K62VkzIl8uNYb+AOeO9/i9y385BbdtaI3UOyeMH9lrXq19RhriGTKU6aThzO9w+A9Kx",
	"Z/kyyq82zfu3Or8kLT4tnCdXV4e+iELvWVNyc2uxeFd6n3WBh6+3kJ8ws3/UISUSOIDp/dMaq5P/Cs+X",
	"YPQnjAsb10AfkhZfrdLHMSmWC/3G80worW8LdKcdx6Eha83NCHBdOz4do02dc/GO7CPLolXHzvJRkR+j",
	"vf/VIj08QTwO9ZZEjYXW6tcR95mNJFfa/4+++KodvnP590PvOxcf2e67CxwJPfZDv65+KBw2jpolVqjl",
	"NHZj3FxDqYr6ggv67G6EL1aum2stDamrN2OZy4I2yqeqwPaRlp+rCJcfHh9XhB8eR61AOgr7HWTqlx8M",
	"euN/lOQo1M31ALw+PRrYSAVCFNjijk4PCW1Aago9PnS62vfQWP92Adck0/Y30+/3lbmDSfWCHX5Odq7b",
	"l7Ss7e4tyY/3N9+ZlL/+6XD2HujzZ0Tn5Lc+Gb6I7P9ttK/tf/Gk0B6P8u7glbMXQod3O+ODNySY2Ozf",
	"7v8TAAD//45Jts8LFQAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
