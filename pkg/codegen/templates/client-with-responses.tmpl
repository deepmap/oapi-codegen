// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
    ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
    client, err := NewClient(server, opts...)
    if err != nil {
        return nil, err
    }
    return &ClientWithResponses{client}, nil
}

{{$clientTypeName := opts.OutputOptions.ClientTypeName -}}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *{{ $clientTypeName }}) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
{{range . -}}
{{$hasParams := .RequiresParamObject -}}
{{$pathParams := .PathParams -}}
{{$opid := .OperationId -}}
    // {{$opid}} request{{if .HasBody}} with any body{{end}}
    {{$opid}}{{if .HasBody}}WithBody{{end}}WithResponse(ctx context.Context{{genParamArgs .PathParams}}{{if .RequiresParamObject}}, params *{{$opid}}Params{{end}}{{if .HasBody}}, contentType string, body io.Reader{{end}}, reqEditors... RequestEditorFn) (*{{genResponseTypeName $opid}}, error)
{{range .Bodies}}
    {{if .IsSupportedByClient -}}
        {{$opid}}{{.Suffix}}WithResponse(ctx context.Context{{genParamArgs $pathParams}}{{if $hasParams}}, params *{{$opid}}Params{{end}}, body {{$opid}}{{.NameTag}}RequestBody, reqEditors... RequestEditorFn) (*{{genResponseTypeName $opid}}, error)
    {{end -}}
{{end}}{{/* range .Bodies */}}
{{end}}{{/* range . $opid := .OperationId */}}
}

{{range .}}{{$opid := .OperationId}}{{$op := .}}
type {{genResponseTypeName $opid | ucFirst}} struct {
    Body         []byte
	HTTPResponse *http.Response
    {{- range getResponseTypeDefinitions .}}
    {{.TypeName}} *{{.Schema.TypeDecl}}
    {{- end}}
}

// Status returns HTTPResponse.Status
func (r {{genResponseTypeName $opid | ucFirst}}) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r {{genResponseTypeName $opid | ucFirst}}) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}
{{end}}


{{range .}}
{{$opid := .OperationId -}}
{{/* Generate client methods (with responses)*/}}

// {{$opid}}{{if .HasBody}}WithBody{{end}}WithResponse request{{if .HasBody}} with arbitrary body{{end}} returning *{{genResponseTypeName $opid}}
func (c *ClientWithResponses) {{$opid}}{{if .HasBody}}WithBody{{end}}WithResponse(ctx context.Context{{genParamArgs .PathParams}}{{if .RequiresParamObject}}, params *{{$opid}}Params{{end}}{{if .HasBody}}, contentType string, body io.Reader{{end}}, reqEditors... RequestEditorFn) (*{{genResponseTypeName $opid}}, error){
    rsp, err := c.{{$opid}}{{if .HasBody}}WithBody{{end}}(ctx{{genParamNames .PathParams}}{{if .RequiresParamObject}}, params{{end}}{{if .HasBody}}, contentType, body{{end}}, reqEditors...)
    if err != nil {
        return nil, err
    }
    return Parse{{genResponseTypeName $opid | ucFirst}}(rsp)
}

{{$hasParams := .RequiresParamObject -}}
{{$pathParams := .PathParams -}}
{{$bodyRequired := .BodyRequired -}}
{{range .Bodies}}
{{if .IsSupportedByClient -}}
func (c *ClientWithResponses) {{$opid}}{{.Suffix}}WithResponse(ctx context.Context{{genParamArgs $pathParams}}{{if $hasParams}}, params *{{$opid}}Params{{end}}, body {{$opid}}{{.NameTag}}RequestBody, reqEditors... RequestEditorFn) (*{{genResponseTypeName $opid}}, error) {
    rsp, err := c.{{$opid}}{{.Suffix}}(ctx{{genParamNames $pathParams}}{{if $hasParams}}, params{{end}}, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return Parse{{genResponseTypeName $opid | ucFirst}}(rsp)
}
{{end}}
{{end}}

{{end}}{{/* operations */}}

{{- /* Generate parse functions for responses */ -}}
{{- define "unmarshal-condition" -}}
    {{- if eq . "1XX" "2XX" "3XX" "4XX" "5XX" -}}
    case rsp.StatusCode / 100 == {{slice . 0 1}}:
    {{- else if eq . "default" -}}
    default:
    {{- else -}}
    case rsp.StatusCode == {{.}}:
    {{- end}}
{{- end}}{{- /* define "unmarshal-condition" */ -}}

{{- define "unmarshal-case" -}}
    var dest {{.TypeDecl}}
    if err := {{.Handler}}.Unmarshal(bodyBytes, &dest); err != nil {
        {{- $name := .TypeDecl}}
        {{- if hasPrefix $name "struct {"}}
        {{- $name = "struct"}}
        {{- else}}
        {{- $parts := split $name "."}}
        {{- $name = index $parts (sum (len $parts) -1)}}
        {{- end}}
        return nil, fmt.Errorf(`decode {{.Handler}} for "{{$name}}": %w`, err)
    }

    resp.{{.TypeName}} = &dest
{{- end}}{{- /* define "unmarshal-case" */ -}}

{{- define "unmarshal-response" -}}
    {{- if .GetResponseTypeDefinitions}}
        {{- /* Find unique types */ -}}
        {{ $typeHandlers := dict}}
        {{ $typeCounts := dict}}
        {{- range .GetResponseTypeDefinitions}}
            {{- $handler := ""}}
            {{- if or (eq .ContentTypeName "application/json" "text/x-json")
                (hasSuffix .ContentTypeName "+json")}}
                {{- $handler = "json"}}
            {{- else if or (eq .ContentTypeName "application/yaml" "application/x-yaml" "text/yaml" "text/x-yaml")
                (hasSuffix .ContentTypeName "+yaml")}}
                {{- $handler = "yaml" -}}
            {{- else if or (eq .ContentTypeName "application/xml" "text/xml" "application/problems+xml")
                (hasSuffix .ContentTypeName "+xml")}}
                {{- $handler = "xml" -}}
            {{- end}}
            {{- $typeHandlers = set $typeHandlers .ContentTypeName $handler}}
            {{- $count := get $typeCounts $handler}}
            {{- if not $count}}{{$count = 0}}{{end}}
            {{- $typeCounts = set $typeCounts $handler (sum $count 1)}}
        {{- end}}{{- /* range .GetResponseTypeDefinitions */}}

        {{- $op := .}}
        contentType := rsp.Header.Get("Content-Type")
        switch {
        {{- range $handler, $count := $typeCounts}}
            {{- $i := 0 -}}
            {{- range $op.GetResponseTypeDefinitions}}
                {{- if not (eq (get $typeHandlers .ContentTypeName) $handler)}}
                    {{- continue}}
                {{- end}}

                {{- $i = sum $i 1}}
                {{- if eq $i 1 }}
                case strings.Contains(contentType, "{{$handler}}"):
                    switch {
                {{- end}}
                {{template "unmarshal-condition" .ResponseName}}
                {{- if $handler}}
                    {{template "unmarshal-case" dict "TypeName" .TypeName "TypeDecl" .Schema.TypeDecl "GoType" .Schema.GoType "Handler" $handler}}
                {{- else}}
                 // Unsupported Content-Type {{.ContentTypeName}} TypeName {{.TypeName}}
                {{- end}}

                {{- if eq $i $count}}
                    }
                {{- end}}
            {{- end}}{{/* range $op.GetResponseTypeDefinitions */}}
        {{- end}}{{/* range .GetResponseTypeDefinitions */ -}}
        }
    {{- end}}{{/* if .GetResponseTypeDefinitions */ -}}
{{- end}}{{/* define "unmarshal-response" */ -}}

{{range .}}{{$opid := .OperationId}}

// Parse{{genResponseTypeName $opid}} parses an HTTP response from a {{$opid}}WithResponse call
func Parse{{genResponseTypeName $opid}}(rsp *http.Response) (*{{genResponseTypeName $opid}}, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer rsp.Body.Close() //nolint: errcheck
    if err != nil {
        return nil, err
    }

    resp := &{{genResponseTypeName $opid}}{
        Body: bodyBytes,
        HTTPResponse: rsp,
    }

    {{template "unmarshal-response" .}}

    return resp, nil
}
{{end}}{{/* range . $opid := .OperationId */}}
